之前一直没重现本地包内的木兰模块引用，导致提取出的模块只能放在项目根目录下。

上周终于搞定。于是将上次的摆放规划应用的源码拆分成几个模块，比如`测试/实用/规划/点.ul`，在主模块中可以如此引用`using 点 in 测试.实用.规划.点`。不需要在包中放置类似`__init__.py`。

## 其他新添功能

### 字符串拼接时的报错信息
```
(..•˘_˘•..) 字符串只能拼接字符串，请将"int"先用 str() 转换
见第1行：print("1" + 2)
```

### 对匿名函数指定返回类型
```javascript
type 形状 {
{}
}
print(func (边长) : 形状 {
  return 形状()
}(1) != nil)
```

### 查询字典中是否包含某个键

之前是用`__contains__`，一直觉得不爽，现在用`get`代替，比如：`字集.get(字) != nil`

## 新实例

最近看到幼儿数学启蒙时的一种“凑十法”，比如求 9+7，先把 7 拆为 1 和 6，而 9+1 = 10，最终得出 16。感觉小孩似乎不需要真正用“加法”运算。模拟解题过程如下：
```javascript
拆分 = {
  2 : [[1, 1]],
  3 : [[1, 2]],
  4 : [[1, 3], [2, 2]],
  5 : [[1, 4], [2, 3]],
  6 : [[1, 5], [2, 4], [3, 3]],
  7 : [[1, 6], [2, 5], [3, 4]],
  8 : [[1, 7], [2, 6], [3, 5], [4, 4]],
  9 : [[1, 8], [2, 7], [3, 6], [4, 5]],
  10 : [[1, 9], [2, 8], [3, 7], [4, 6], [5, 5]]
}

func 取剩余(整体, 部分) {
  for 两部分 in 拆分[整体] {
    if 两部分[0] == 部分 {
      return 两部分[1]
    } elif 两部分[1] == 部分 {
      return 两部分[0]
    }
  }
}

func 凑十法求和(基数, 被拆数) {
  凑数 = 取剩余(10, 基数)
  拆得数 = 取剩余(被拆数, 凑数)
  return "1" + str(拆得数)
}

println(凑十法求和(9, 7))
```
本来可以用`index`取列表中元素所在位置，但由于尚未支持捕获异常，只得用原始搜索。

## 代码统计

下面是几个主要部分的代码行数统计，格式为：上次->现在。

- 测试
  - 木兰测试用例：1590 -> 1700
  - `运行测试.py`，检验所有木兰测试代码片段：154 -> 156
  - 未变
  	- `test语法树.py`，确保生成的语法树与原始版本一致：67

- 实现：2183 -> 2169
  - `分析器/语法分析器.py`：944 -> 881
  - `分析器/语法树.py` 对 ast 库的中文封装，进行了重构简化代码：234 -> 178
  - `环境.py`，加载木兰模块：97 -> 123
  - `分析器/语法成分.py`，从语法分析器中提取出来的枚举常量：77
  - `功用/反馈信息.py`：45 -> 49
  - 未变
    - `分析器/词法分析器.py`：190
  	- `演示高亮.py`：100
    - `中.py`，主程序：36